Should version specific features (eg LRA Remount/bugfixes or .com Scarf) be plugins?

TODO: use traits to separate out testable logic from implementation specific to registry
/logic
/template

timeline engine operations
- caching point states for each frame (basic clone)
- caching mount states for each frame (basic clone)
- removing from and adding to cache size whenever mounts change
- clearing front of cache whenever lines change
- swapping cached point states whenever frame info requested
- moving green lines?

Engine Constraints
Skeletons: <= 50
Bones: <= 2,500
Points: <= 2,500
Mounts: <= 25
Physics Lines <= 10,000
Scenery Lines <= ~100,000,000?

idea: vec with mount bone/joint diffs at different frames, then cumulatively construct by moving along
frame 0: list[(id, id), (id, id), ...]
frame 10: list[(id, id), (id, id), ...]
frame 20: list[(id, id), (id, id), ...]

idea: skeletons and mounts as traits
- allow for custom skeleton/mount implementations
- traits describe required functions for usage

entity registry operations
- adding and removing individual skeletons (cascade delete)
- adding and removing mounts (unlink skeletons)
- adding and removing skeleton templates (cascade delete)
- adding and removing mount templates (linking two skeleton templates)
- building new skeleton templates?
- building new mount templates?
- resolving entity component id lookups

API for defining skeleton templates
let mut b = registry.skeleton_template();

let p1 = b.point(Vec2::new(0.0, 0.0));
let p2 = b.point(Vec2::new(1.0, 0.0));
b.bone(p1, p2).joint(p1, p2);

let skeleton_id = b.build();

API for accepting serialized skeleton templates
registry.add_skeleton_template(SkeletonTemplate {
    points: vec![
        Point { pos: vec2(0.0, 0.0), friction: 0.5 },
        Point { pos: vec2(1.0, 0.0), friction: 0.5 },
    ],
    bones: vec![(0, 1)],
    joints: vec![(0, 1)],
});

let serialized = registry.serialize_skeleton_template(skeleton_id);
